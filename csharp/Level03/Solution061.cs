/*
    Problem: 61

    Title: Cyclical figurate numbers

    Description:
        Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
        all figurate (polygonal) numbers and are generated by the following formulae:
        
        Triangle     P[3,n]=n(n+1)/2    1, 3, 6, 10, 15, ...
        Square       P[4,n]=n^2         1, 4, 9, 16, 25, ...
        Pentagonal   P[5,n]=n(3n−1)/2   1, 5, 12, 22, 35, ...
        Hexagonal    P[6,n]=n(2n−1)     1, 6, 15, 28, 45, ...
        Heptagonal   P[7,n]=n(5n−3)/2   1, 7, 18, 34, 55, ...
        Octagonal    P[8,n]=n(3n−2)     1, 8, 21, 40, 65, ...
        
        The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
        interesting properties.
        
            1. The set is cyclic, in that the last two digits of each number is the first
            two digits of the next number (including the last number with the first).
            2. Each polygonal type: triangle (P[3,127]=8128), square (P[4,91]=8281), and
            pentagonal (P[5,44]=2882), is represented by a different number in the set.
            3. This is the only set of 4-digit numbers with this property.
        
        Find the sum of the only ordered set of six cyclic 4-digit numbers for which
        each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
        octagonal, is represented by a different number in the set.
        

    Url: https://projecteuler.net/problem=61
*/

using System;
using System.Collections.Generic;
using System.Linq;
using csharp.Utility;

namespace csharp.Level03
{
    
    public class Solution061 : SolutionBase
    {
        private class CyclicalComparer : IEqualityComparer<ulong>
        {
            private readonly int _digitCount;

            public CyclicalComparer(int digitCount)
            {
                _digitCount = digitCount;
            }

            public bool Equals(ulong x, ulong y)
            {

                if (x == y)
                    return false;
                var dx = ToolBox.NumberToDigits(x).ToArray();
                var dy = ToolBox.NumberToDigits(y).ToArray();
                if (dx.Length != dy.Length || dx.Length <= _digitCount)
                    return false;
                for (int i = 0; i < _digitCount; i++)
                {
                    if (dy[i] != dx[dx.Length - _digitCount + i])
                        return false;
                }
                return true;
            }

            public int GetHashCode(ulong obj)
            {
                return 0;
            }
        }
        

        private IEnumerable<ulong> GenerateSequence(ulong seedStart, ulong min, ulong max, Func<ulong, ulong> generator)
        {
            ulong i = seedStart;
            while (generator(++i) < min) ;
            for (var n = generator(i); n <= max; n = generator(++i))
                yield return n;
        }

        private bool Eval(ulong[] set, int depth, ulong[][] sets, IEqualityComparer<ulong> comparer)
        {
            if (depth == set.Length)
                return comparer.Equals(set[depth-1], set[0]) && set.Distinct().Count() == set.Length;

            for (int i = 0; i < sets[depth].Length; i++)
            {
                set[depth] = sets[depth][i];
                if (comparer.Equals(set[depth - 1], set[depth]) &&
                    Eval(set, depth + 1, sets, comparer))
                    return true;
            }
            return false;
        }

        public override object Answer()
        {
            var funcs = new Func<ulong, ulong>[]
            {
                n => n*(n + 1)/2,
                n => n*n,
                n => n*(3*n - 1)/2,
                n => n*(2*n - 1),
                n => n*(5*n - 3)/2,
                n => n*(3*n - 2)
            };
            
            var sets = funcs.Select(f => GenerateSequence(0, 999, 9999, f).ToArray()).ToArray();
            var comparer = new CyclicalComparer(2);
            var set = new ulong[sets.Length];

            foreach (var setsPermutation in ToolBox.Permutate(sets))
            {
                for (int i = 0; i < setsPermutation[0].Length; i++)
                {
                    set[0] = setsPermutation[0][i];
                    if (!Eval(set, 1, setsPermutation.ToArray(), comparer))
                        continue;
                    return set.Aggregate(0ul,(a,b)=>a+b);
                }
            }
            return 0;
        }
    }
}

